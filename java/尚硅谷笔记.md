#### 第八章 多线程

##### 1. 程序，进程，线程

1. 进程和线程的区别
   1. 进程

      进程是资源分配的最小单位，系统运行时会为进程分配不同的内存区域。

   2. 线程

      线程是调度和执行的最小单位，每个线程拥有独立的运行栈和程序计数器。线程切换的开销小

      一个进程中的多个线程共享相同的内存单元/内存地址空间。他们在同一堆中分配对象，可以访问相同的变量个对象。

2. 进程分配的资源都包括什么？

3. 线程的运行栈和程序计数器是什么？

4. 线程创建的开销是什么

5. java的应用程序至少有三个线程，main线程，gc线程，异常处理线程。当发生异常时，会影响主线程

6. 多线程的优点

   1. cpu充分使用，
   2. 多核情况下充分使用cpu



##### 2. *线程的创建和使用*

1. 线程有哪些创建方式？
   1. 继承 Thread 类，重写run()方法。使用start启动。
   
   2. 实现runnable接口，使用Thread包装实现类。使用Thread start方法启动Thread。start方法会判断target是不是为空。
   
   3. 实现callable接口
   
      1. 与实现runable接口的区别
         1. 获取返回值
         2. 可以抛出异常
      2. 实现方法，实现callable接口，然后通过futuretask 类启动线程。futuretask支持对
   
   4. 使用线程池。
   
      ```
      Executors.newFixedThreadPool(10)
      service.submit()
      service.run()
      ```
   
      
   
2. runnable 和 callable的区别

   1. callable可以有返回值
   2. 可以抛出异常
   3. 可以使用泛型

3. runnable和Thread类两种方式的比较？
   1. 推荐使用runnable接口
   2. java是单继承的，使用继承方式会影响继承体系
   3. 同一个runnable实现对象可以传给多个Thread，这样可以使共享数据封装在更小的对象范围内。

4. start方法的作用以及实现？？ 未解决
   1. 启动线程
   2. 调用run方法
   3. 同一个现场只能start一次，在start方法中有状态锁。

5. Thread的常用方法
   1. getName()； setName();
   2. join();在线程a中调用线程b，此时线程a进入阻塞状态，知道线程b完全执行完成以后，线程a才结束阻塞状态。

6. 线程的优先级有多少个，最小是多少，最大是多少，正常线程优先级是什么。

   1. 最高为10，最小为1， 正常为5

7. join实现原理？？

8. java守护线程的用户线程的区别？

   1. 守护线程是服务与用户线程的

##### 3. 线程的生命周期

 1. Thread.State定义了java线程的状态

 2. ```
    new , runnable， block， waitting  timedWaiting ,terminated
    
    新建， 就绪， 运行， 阻塞，死亡
    ```

    ![Screen Shot 2019-09-19 at 10.49.02 AM](Screen Shot 2019-09-19 at 10.49.02 AM-8904588.png)

##### ***4. 线程的同步***

1. java线程同步的方法?
   
   1. 同步代码块
   
      ```
      synchronized(同步监视器){
          //需要同步的代码。
        }
        操作共享数据的代码被称为需要同步的代码。
        
       同步监视器：锁。任何一个类的对象都可以充当为锁。但是必须是同一个锁。
       runnable中可以考虑使用this作为锁
       在继承方式中可以考虑使用当前类作为锁。
      ```
   
   2. 同步方法：非静态同步方法的锁是this。静态的同步方法的锁是当前类本身。
   
      如果操作共享数据的代码完整的声明在一个方法中，可以把该方法生命为同步方法。
   
   3. ReentrantLock
   
2. synchronized和reentrantLock的区别

   1. 自动，手动加锁释放锁。
   2. lock效率更好。

3. Synchronized中锁的对象是如何实现的，synchronized的实现，其实现与lock的区别。

##### 5. 线程的通信

1. 一下三个方法中只能放在同步代码块中和同步方法中，并且调用者必须是同步监视器

   wait  notify 唤醒被wait的线程，多个线程被wait，唤醒优先级高的。 notifyall 唤醒所有wait的方法。

2. sleep和wait的区别

   1. 执行后当前线程都会阻塞
   2. sleep方法则Thread中声明， wait在object中声明
   3. sleep在任何地方都可以使用，wait只能在同步代码块中
   4. sleep不会释放锁，wait会释放锁

3. 实现一个生产者消费者

   1. 生产者
   2. 消费者
   3. channel

