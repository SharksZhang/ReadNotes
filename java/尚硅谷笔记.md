#### 第八章 多线程

##### 1. 程序，进程，线程

1. 进程和线程的区别
   1. 进程

      进程是资源分配的最小单位，系统运行时会为进程分配不同的内存区域。

   2. 线程

      线程是调度和执行的最小单位，每个线程拥有独立的运行栈和程序计数器。线程切换的开销小

      一个进程中的多个线程共享相同的内存单元/内存地址空间。他们在同一堆中分配对象，可以访问相同的变量个对象。

2. 进程分配的资源都包括什么？

3. 线程的运行栈和程序计数器是什么？

4. 线程创建的开销是什么

5. java的应用程序至少有三个线程，main线程，gc线程，异常处理线程。当发生异常时，会影响主线程

6. 多线程的优点

   1. cpu充分使用，
   2. 多核情况下充分使用cpu



##### 2. *线程的创建和使用*

1. 线程有哪些创建方式？
   1. 继承 Thread 类，重写run()方法。使用start启动。
   
   2. 实现runnable接口，使用Thread包装实现类。使用Thread start方法启动Thread。start方法会判断target是不是为空。
   
   3. 实现callable接口
   
      1. 与实现runable接口的区别
         1. 获取返回值
         2. 可以抛出异常
      2. 实现方法，实现callable接口，然后通过futuretask 类启动线程。futuretask支持对
   
   4. 使用线程池。
   
      ```
      Executors.newFixedThreadPool(10)
      service.submit()
      service.run()
      ```
   
      
   
2. runnable 和 callable的区别

   1. callable可以有返回值
   2. 可以抛出异常
   3. 可以使用泛型

3. runnable和Thread类两种方式的比较？
   1. 推荐使用runnable接口
   2. java是单继承的，使用继承方式会影响继承体系
   3. 同一个runnable实现对象可以传给多个Thread，这样可以使共享数据封装在更小的对象范围内。

4. start方法的作用以及实现？？ 未解决
   1. 启动线程
   2. 调用run方法
   3. 同一个现场只能start一次，在start方法中有状态锁。

5. Thread的常用方法
   1. getName()； setName();
   2. join();在线程a中调用线程b，此时线程a进入阻塞状态，知道线程b完全执行完成以后，线程a才结束阻塞状态。

6. 线程的优先级有多少个，最小是多少，最大是多少，正常线程优先级是什么。

   1. 最高为10，最小为1， 正常为5

7. join实现原理？？

8. java守护线程的用户线程的区别？

   1. 守护线程是服务与用户线程的

##### 3. 线程的生命周期

 1. Thread.State定义了java线程的状态

 2. ```
    new , runnable， block， waitting  timedWaiting ,terminated
    
    新建， 就绪， 运行， 阻塞，死亡
    ```

    ![Screen Shot 2019-09-19 at 10.49.02 AM](Screen Shot 2019-09-19 at 10.49.02 AM-8904588.png)

##### ***4. 线程的同步***

1. java线程同步的方法?
  
   1. 同步代码块
   
      ```
      synchronized(同步监视器){
          //需要同步的代码。
        }
        操作共享数据的代码被称为需要同步的代码。
        
       同步监视器：锁。任何一个类的对象都可以充当为锁。但是必须是同一个锁。
       runnable中可以考虑使用this作为锁
       在继承方式中可以考虑使用当前类作为锁。
      ```
   
   2. 同步方法：非静态同步方法的锁是this。静态的同步方法的锁是当前类本身。
   
      如果操作共享数据的代码完整的声明在一个方法中，可以把该方法生命为同步方法。
   
   3. ReentrantLock
   
2. synchronized和reentrantLock的区别

   1. 自动，手动加锁释放锁。
   2. lock效率更好。

3. Synchronized中锁的对象是如何实现的，synchronized的实现，其实现与lock的区别。

##### 5. 线程的通信

1. 一下三个方法中只能放在同步代码块中和同步方法中，并且调用者必须是同步监视器

   wait  notify 唤醒被wait的线程，多个线程被wait，唤醒优先级高的。 notifyall 唤醒所有wait的方法。

2. sleep和wait的区别

   1. 执行后当前线程都会阻塞
   2. sleep方法则Thread中声明， wait在object中声明
   3. sleep在任何地方都可以使用，wait只能在同步代码块中
   4. sleep不会释放锁，wait会释放锁

3. 实现一个生产者消费者

   1. 生产者
   2. 消费者
   3. channel

#### 第九章 java常用类

##### 1. String 

1. string的底层实现？

   1. String 是final的，不能被继承。
   2. 实现了 Serializable, Comparable接口
   3. 底层是一个不可变的char数组。

2. String str1 = "abc" 与String str2 = new String("abc");的区别

   使用字面量方法声明，临时变量中存储的是常量池中的地址。使用new方法，会先在堆中开辟内存，临时变量指向堆中的地址，堆中分配的内存指向常量池中对应的字符串。

3. String s1 = "a" String s2 ="b" String s3= "ab";  String s4 = s1 + s2;  s5 = s1 + "b" .s4 == s3?  s5 == s3?

   true, false.有变量参与的字符串相加，都会现在堆中开辟内存。

   常量与常量的拼接，直接在常亮池中，且常量池中不会有相同常量的内容。

   只要其中有一个变量，结果就会在堆中。  

4. 字符串在jvm是如何存储的

   1. 字符串常量池。字符串常量池在方法区

5. String与其它类型的转换？

   1. 与基本类型的转换
      1. Integer.parseInt(str1);
      2. String.valueOf(num);
   2. 与char[]之间的转换
      1. String.toCharArray();
      2. String.new(char[] ch)
   3. 与byte[]之间的转换
      1. "".getBytes();可以用参数指定字符集
      2. new String() 同样可以指定编码集

6. String.Intern()方法返回常量池中的地址

7. String, StringBuffer, stringBuilder之间的区别

   1. StringBuffer线程安全的，都是同步方法。可变字符串
   2. StringBuilder非线程安全的，效率更高。可变字符串

   

8. StringBuffer的底层实现和扩容。

   1. 底层创建一个默认长度为指定串+16的数组。
   2. 当长度不够时，创建一个容量为原有容量左移移位并加二容量，并复制原有数组。
   3. StringBuffer可以指定底层数组容量创建。

9. final关键字的实现。

   1. 未解决

10. String为什么要是不可变的？为什么要把String放在常量池中

    

##### 2. 日期和时间

1. Date类(大多数方法已经过时了)

   1. java.lang.System.CurrentMillis()获取时间戳
   2. date可以无参数保存当前时间，也可以使用ms数创建。

2. java.text.simpleDateFormat用于格式化日期输出。

   ```
   SimpleDateFormat  sdf = new SimpleDateFormat(“yyyy-MM-dd”);
   解析：java.util.Date date = sdf.parse(“2017-08-16”);
   
   DateTimeFormatter dtf= DateTimeFormatter.ofPattern(“yyyy-MM-dd”); 
   
   ```

3. Calendar类(抽象类)

   1. Calendar.getInstance();
   2. get/set/add/getTime/SetTime
   3. 月份1月是0.星期 周日是1

4. java.time包

   1. date相关类
      1. 一下三个都是不可变的，设置以后会返回新的。
      2. LocalDate
      3. LocalTime
      4. DlocalDateTime.of()  .now()
   2. instant(类似于date)
   3. DateTimeFormatter (类似于SampleDateFormat)

5. JDK 8之前和JDK8中日期、时间相关的类分别有哪些？

   java.util.Date 和 java.sql.Date  ->  Instant

   SimpleDateFormat  -> DateTimeFormatter

   Calendar  -> LocalDate、LocalTime、LocalDateTime

##### 3 .java比较器

​	Comparable或 Comparator

1. comparable接口
2. Comparator

##### 4. System类

​	表示系统。有很多系统相关方法

​	1. in，out， err。表示输入，输出，错误。

##### 5. Math类

​	关于数学的方法。

##### 6. BigInteger 与BigDecimal

​	BigInteger表示不可变的任意精度的整数。

​	BigDecimal类似，代表浮点型。



##### 

##### 第十章枚举类和注解

##### 枚举类

1. 什么是枚举类，什么时候使用枚举类
   1. 类中的对象个数是确定的，有限的。
   2. 当需要定义一组常亮时，使用枚举类。
2. 如何定义枚举类
   1. 使用enum关键字定义
   2. 使用enum关键字的类继承在java.lang.Enum类
3. Enum类常用方法
   1. values() 列举枚举类的所有状态
   2. valueOf()根据obj名返回枚举对象。
4. 使用enum关键字定义的枚举类实现接口
   1. 直接让枚举类实现方法
   2. 让枚举类里的每一个对象实现接口方法

##### 注解(annotation)

1. 注解概述
   1. 代码里的特殊标记，在编译，类加载，运行时被读取，并执行相应的处理。
2. 常见的注解
   1. 生成文档相关的注解。
   2. 编译时进行格式检查
      1. @override  @ deprecated  @suppressWarnings(抑制编译器警告)
   3. 跟踪代码依赖性，实现替代配置的功能
3. 自定义注解
   1. 声明@interface
   2. 自动继承java.lang.annotation.Annotation接口
   3. 成员变量使用无参数方法来声明
4. 什么是元注解，Retention注解和target注解的作用。
   1. 修饰其它注解的注解
   2. Retention:用于指定注解的生命周期。有三个枚举值source：在编译器扔掉， Class：保留在class中(默认行为)  RunTime ：保留至运行时
   3. Target：由于指定注解可以修饰那种类型。
   4. Documented：表示所修饰的注解在javadoc解析时保留下来
   5. Inherited ： 注解会被子类继承。
5. 利用反射获取注解信息
   1. 学习注解是学习。
6. jdk8中注解的新特性
   1. 可重复注解：@Repeatable()修饰注解。
   2. 类型注解新增两个：增加了泛型类型，类型注解
7. 注解的底层实现？

#### 第十一章 java集合

##### 1. Collection 接口方法

1. 概述集合框架的体系

   ```
   Collection接口： 单列数据，定义了存取一组对象的方法的结合
   	List：元素有序，可重复的集合。
   		vector
   		ArrayList
   		LinkedList
   	Set： 元素无序，不可重复的集合。
   		HashSet
   			LinkedHashSet
   		SortedSet
   			TreeSet
   Map接口：双列数据，保存具有映射关系key-value对的集合。
   		HashMap
   			LinkedHashMap
   		HashTable
   			properties
   		SortedMap
   			TreeMap
   ```

   ![Screen Shot 2019-09-23 at 3.07.44 PM 1](Screen Shot 2019-09-23 at 3.07.44 PM 1-9265700.png)

![Screen Shot 2019-09-23 at 3.09.45 PM](Screen Shot 2019-09-23 at 3.09.45 PM.png)

2. Collection接口的方法。

   1. 15个方法。
   2. add()/addAll(Collection);
   3. size()/isEmpty();
   4. clear();
   5. contains()/containsall();调用equals()方法。
   6. remove()/removeAll(Collection) 需要重写equals()方法。
   7. retainAll(Collection) 获取交集
   8. equals()： 所有集合元素相等则相等。有序的和元素顺序相关。
   9. hashCode() 
   10. 集合转换为数组：toArray(); 数组转集合Arrays.asList(T … a);
   11. Iterator() 返回Iterator实例。每次调用都会返回迭代器方法。

3. Iterator迭代器接口有什么方法？

   1. next()
   2. hasNext()
   3. remove()

   ##### 2. Collection 子接口一：List

   1. ArrayList
   2. LinkedList
   3. Vector

   1. ArrayList, linkedList, Vector的异同
      1. 相同点
         1. 实现了List接口， 存储有序，元素可重复
         2. Vector 和ArrayList 底层都是[]Object数组。
      2. 不同点
         1. ArrayList 非线程安全， Vector线程安全。
         2. ArrayList和Vector底层使用[]Object 数组存储,对于频繁查找使用。
         3. LinkedList 非连续存储，底层使用双向链表存储，对于频繁插入和删除操作使用linkedList
   2. ArrayList的源码分析
      1. jdk7	
         1. 底层存储结构是一个Object[]数组
         2. 构造器
            1. 空参构造器：初始化一个容量为10的数组。
            2. 带容量构造器：直接初始化一个指定容量的底层数组。
         3. 添加操作
            1. 确认容量是否够，如果不够扩容，扩容为当前容量 + 当前容量右移1位(1.5倍)
            2. 复制原有的数组。
      2. jdk8的变化：
         1. 构造器
            1. 空参构造器：赋值为一个长度为0的空数组，不提前分配内存。
         2. 添加操作
            1. 第一次添加操作时，底层创建长度为10的数组，然后添加。
         3. 更节省内存，延迟初始化。

4. LinkedList 源码分析

   1. 底层是一个双向链表。保存First, Last节点
   2. 初始花式 first 和last都为空

5. Vector源码分析

   1. 扩容方式和ArrayList有区别，其它都相同，默认使用长度为10的初始化
   2. 扩容新的容量为2倍。
   3. vector使用的较少。多线程情况下也可以用arrayList解决。

6. ListIterator和 collection Iterator的区别？

   1. ListIterator可以添加元素
   2. ListIterator可以定位当前索引的位置
   3. ListIterator可以双向迭代

   ##### 3. Collection 子接口二：Set

   1. Set接口的结构

      ```
      Set
      	HashSet
      		LinkedHashSet作为HashSet的子类出现，遍历内部顺序时会按照添加时顺序遍历。
      	SortedSet
      		TreeSet：使用红黑树存储，可以按照指定属性排序。
      ```

   2. HashSet的实现

      1. 底层是使用了hashMap实现。
      2. jdk 1.7初始化一个  长度为16的数组 + 链表， jdk1.8在添加时初始化，底层有变化。
      3. 添加
         1. 使用hash值通过散列函数计算出在数组中的位置
            1. 判断此位置是否有元素，如果此位置无元素，则直接添加成功
            2. 如果此位置有元素，则比较hash值，
               1. 如果hash值不相同，则添加成功
               2. 如果hash值相同，则比较equals()方法
                  1. 不相同则添加。
                  2. 相同则添加失败
         2. 在jdk1.7中 新元素链接旧元素，jdk1.8中旧元素链接新元素。
      4. 扩容
         1. 当装填因此大于0.75，则扩容

   3. 向set中添加的元素有什么要求

      1. 必须重写hashCode()方法和queals()方法，相同的对象必须具有相同的散列码。
      2. 对象中用作equal作为比较的Field()，都应该用来计算hashCode().

   4. HashCode()方法的实现？

      1. 在object中的hashCode()方法是一个随机数。

   5. equals()方法的实现?

   6. linkedHashSet()的实现

      1. 在原有的基础上根据每个数据增加了前后数据的指针。

      

   7. HashSet的遍历顺序是什么？

   ##### 4. Map接口

   1. map接口继承结构是什么

   ```
   Hashtable(古老实现类，线程安全)
   
   	Properties -- 常用来处理配置文件，key和value都是String类型
   
   HashMap(线程不安全，效率高)
   
   	LinkedHashMap(保证在遍历时可以按照添加的顺序实现遍历)
   
   SortedMap
   
   	TreeMap(进行按顺序排序，按照顺序遍历) 底层是一个红黑树
   ```

   2. HashMap和HashTable的区别
      1. hashMap非线程安全，效率高。HashTable线程安全，效率低
      2. HashMap可以存储null的key和val。HashTable不可以。

   

   3. HashMap的底层实现？1.7和1.8有什么区别。

      1. 初始化： java 1.7 数组 + 链表  java 1.8 数组 + 链表 + 红黑树

         1. 1.7 首次创建时分配初始长度为 16的数组，1.8在首次添加时分配。

      2. 添加

         1. 判断是否存在，存在则更新值，判断是否存在和set相同
         2. 在jdk1.7中 新元素链接旧元素，jdk1.8中旧元素链接新元素。

      3. 扩容

         1. 1.8 当链表长度超过8， 当底层数组长度小于64 ，扩容，当地城数组长度大于64， 将链表改位红黑树。
         2. 当超出临界值，则扩容为原来的两倍， 并重新计算hash

         

    4. map的结构理解

       1. map中的key：无序的， 不可重复的，使用Set存储所有的key
       2. map中的value：无序的，不可重复的，使用Collection存储所有的value
       3. 一个键值对过程一个Entry对象，Map中的entry：无序的，不可重复的，使用Set存储所有的entry

   5. linkedHashmap的实现

      1. 增加了前后指针，在添加时会使用前后指针维护顺序。

   6. map常用方法？

      1. put()/putAll()
      2. remove(Object o);
      3. clear()
      4. get() size(), containsKey() containsValue() isEmpty() 
      5. equeal() 存的数据相同
      6. keySet() Values() entrySet()

   7. TreeMap的底层实现

   8. CurrentHashMap的实现？

   9. 左右移和乘除法效率对比。

   10. hash冲突的解决方法

   11. hash算法？

##### 5. Collections 工具类

1. 排序相关

   1. reverse(List)
   2. shuffle(List)
   3. sort(List)
   4. sort(List, Comparator)
   5. swap(List, int , int)

2. 查找，替换

   1. max(Collection)/max(Collection, Comparator)

   2. min()/min()与max类似

   3. frequency(collection， object) 返回指定对象出现的次数

   4. copy(dest, src)

      1. ```
         List dest = Arrays.asList(new Object[List.size()]);
         Collections.copy(dest, list);
         ```

         

   5. replaceAll(list, oldVal, newVal)

3. 同步控制

   1. synchronizedxxx(list) 返回的list即为线程安全的。

#### 第12章 泛型

##### 1. 为什么要有泛型(Generic)

 	1. 什么是泛型
      	1. 所谓泛型，就是允许在定义类、接口是通过一个标识类中某个属性的类型或者是某个方法的返回值机参数类型，这个类型参数在使用时确定。
      	2. 自己的理解：类型参数化。
	2. 为什么使用泛型
    	1. 类型参数化

##### 3. 自定义泛型结构

​	使用<E1,E2,E3>

 	1. 泛型方法怎么定义
      	1. public<E> List<E> copyFromArrayToList(E[] arr
	2. A是类B的父类，G<A> 和G<B>二者不具备父子类关系

##### 5. 通配符的使用

```
List<?> list 
```

使用通配符只能读不能写

有限制条件的通配符

```
List<?extends Person>
List<? Super Person>
```

​	

#### IO流

##### 1.File类的使用

1. 新建file对象的三种方法

```
public File(String pathname) 以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果 pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。
 绝对路径:是一个固定的路径,从盘符开始  相对路径:是相对于某个位置开始
 public File(String parent,String child) 以parent为父路径，child为子路径创建File对象。
 public File(File parent,String child) 根据一个父File对象和子文件路径创建File对象
```

2. File的常用方法

   1. 获取功能

      1.  public String getAbsolutePath():获取绝对路径
      2.   public String getPath() :获取路径
      3.   publi sc String getName() :获取名称
      4.   public String getParent():获取上层文件目录路径。若无，返回null
      5.   public long length() :获取文件长度(即:字节数)。不能获取目录的长度。 
      6.  public long lastModified() :获取最后一次的修改时间，毫秒值 
      7.  public String[] list() :获取指定目录下的所有文件或者文件目录的名称数组  public File[] listFiles() :获取指定目录下的所有文件或者文件目录的File数 
      8. public boolean renameTo(File dest):把文件重命名为指定的文件路径

   2. 判断

      1. public boolean isDirectory():判断是否是文件目录 

      2.  public boolean isFile() :判断是否是文件
           public boolean exists() :判断是否存在
           public boolean canRead() :判断是否可读 

          public boolean canWrite() :判断是否可写  public boolean isHidden() :判断是否隐藏 

   3. File类的创建功能

      1.  public boolean createNewFile() :创建文件。若文件存在，则不创建，返回false  public boolean mkdir() :创建文件目录。如果此文件目录存在，就不创建了。 

         如果此文件目录的上层目录不存在，也不创建。
           public boolean mkdirs() :创建文件目录。如果上层文件目录不存在，一并创建 

         注意事项:如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目 路径下。 

   4. File类的删除功能

      1. public boolean delete():删除文件或者文件夹 

         删除注意事项: 

         Java中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录 

##### 2. IO流原理及流的分类

1. 流是如何分类的？

   1. 按照数据单位不同：分为字节流(8bit), 字符流(16 bit)(char)(多用于处理文本)
   2. 按照数据流的流向不同：输入流，输出流
   3. 按流的角色的不同分为：节点流（直接作用于文件上的流），处理流	(包装节点流的流)

2. Io的抽象基类

   | 抽象基类 | 字节流       | 字符流 |
   | -------- | ------------ | ------ |
   | 输入流   | InputStream  | Reader |
   | 输出流   | OutputStream | Writer |

3. 如何实现一个文件读取

   1. 实例化File类
   2. 提供具体的流
   3. 数据读入read()
      1. 方法返回第一个字符，如果达到文件末尾，则返回-1.
      2. read方法可以指定缓存数组。此时返回的时该次读取数据的长度。
   4. 关闭流

4. 如何写出数据

   1. 实例化File类对象，指明写出到的文件
      1. 文件可以不存在，不存在会创建
      2. 文件存在可以设置为在后续继续写或者追加
   2. 提供FileWriter的对象，用于数据的写出
   3. 写出操作
   4. 流资源关闭
      1. 关闭外层流内存会自动关闭

5. 节点流(或文件流)有什么
   1. FileInputStream
   2. FileOutputStream
   3. FileReader
   4. FileWriter

6. 字符流和字节流的区别？字符流自带了解码能力？

7. 文件读写在操作系统中的操作？

8. 字节流的默认编解码方式？

9. 常用的处理流有哪些，作用是什么？
   1. 缓冲流的作用，为什么？
      1. BufferedInputStream
      2. BufferedOutputStream
      3. BufferedReader
      4. BufferedWriter
      5. 提高读写的效率
      6. 提供了一个默认的8k的缓冲区。
   2. 转换流都有什么？作用是什么？
      1. 提供了字符流和字节流之间的转换
      2. InputStreamReader  :将字节的输入流转换为字符的输入流(解码)
      3. OutputStreamWriter：将字符的输出流转换为字节的输出流(编码)	
   3. 数据流是什么，什么作用
      1. 为了方便操作java语言的基本数据类型和String的数据，可以使用数据流
      2. DataInputStream 和DataOutputStream
   4. 对象流是什么，什么作用
      1. 用于存储个读取基本数据类型或对象的处理流，它的强大之处就是可以把java的对象写入到数据源中，也能把对象从数据源中还原出来。
      2. ObjectInputStream  (序列化)
      3. ObjectOutputStream(反序列化)

10. 标准输入，输出流是什么有什么作用

    1. System.in 生成标准输入
    2. System.out生成标准输出
    3. 默认是键盘和显示器，可以使用set方法重新设置

11. 打印流是什么，有什么作用？

    1. PrintStream
    2. PrintWriter

12. 对象的序列化机制是什么

    1. 循序把内存中的java对象转换为平台无关的二进制流，并保存或传输。同时可以通过二进制流还原成原来的java对象
    2. 可序列化对象必须实现Serializable接口和Externalizable

13. 如何自定义类实现序列化

    1. 实现Serializable标识接口，没有具体的实现方法
    2. 当前类提供全局常亮：serialVesionUID:标识。如果没有该字段，java会自动生成，但是类改变时，该字段会改变。
    3. 所有的属性也需要时可序列化的。

14. serialVersionUID如何生成才不会重复？

15. 什么是随机存取文件流（RandomAccessFile类）

    1. 直接继承与 object类
    2. 实现了DataInput DataOutput这两个接口。
    3. 该对象包含一个记录指针，用以标示当前读写位置，该对象可以自由移动该指针。

#### 14章网络编程

1. InetAddress类代表一个IP地址

   1. ```
      InetAddress.getByName("www.baidu.com")
      InetAddress.getByName("192.168.10.14")
      ```

2. Socket 和 DatagramSocket URL

3. TCP和UDP的区别

   1. tcp可靠， udp 不可靠
   2. tcp效率低，udp效率高

   

   



#### 15章反射(Reflection)

1. 反射机制是什么

   1. 动态语言的关键，反射允许程序在执行期间借助于Reflection Api取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。
   2. 加载完类之后，在堆内存的方法区中就产生了一个class类型的对象（一个类只有一个class对象），这个对象包含了完成的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，通过这个镜子看到类的结构，我们形象的称之为：反射。

2. 反射提供的功能

   1. 在运行时判断任意对象所属的类
   2. 在运行时构造任意一个类的对象
   3. 判断类所具有的成员和方法
   4. 获取泛型信息
   5. 调用人一个对象的成员变量和方法
   6. 运行时处理注解
   7. 生成动态代理

3. 反射的主要APi

   1. java.lang.Class : 代表一个类
   2. java.lang.reflect.Method代表类的方法
      1. 可以调用私有方法
   3. java.lang.reflect.Field代表类的成员变量
   4. java.lang.reflect.Constructor 代表类的构造器

4. class类是什么，如何获取class实例？重要

   1. class的每个实例代表每个运行时类。

   2. 调用运行时类的属性 .class

      1. ```
         Person.class
         ```

   3. 通过运行时类的对象，调用getClass()

   4. 调用Class的静态方法：ForName(String classPath)

      1. ```
         Class.ForName("java.lang.Person")
         ```

   5. 使用classLoader获取
      1. 每个class对象都可以获取到ClassLoader
      2. ClassLoader.loadClass("com.lang.String")

5. 类的加载过程是什么，

   1. 通过javac命令以后，会生层一个或多个字节码文件(.class)，

   2. 接着我们使用java.exe命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程称为类的加载，加载到内存中的类，我们就称为运行时类，此运行时类，就作为class的一个实例。

   3. 如果主动使用某个类时，该类还未加载到内存中，则系统会通过，如下三个步骤进行初始化

      1. 加载:将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时 数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问 入口(即引用地址)。所有需要访问和使用类数据只能通过这个Class对象。这个加载的 过程需要类加载器参与。 
2. 链接:将Java类的二进制代码合并到JVM的运行状态之中的过程。 
         1. 验证:确保加载的类信息符合JVM规范，例如:以cafe开头，没有安全方面的问题
   2. 准备:正式为类变量(static)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 
         3. 解析:虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程。 
      3. 初始化: 
   1. 执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中 所有类变量的赋值动作和静态代码块中的语句合并产生的。(类构造器是构造类信息的，不是构造该类对象的构造器)。 
         2. 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
   3. 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步 加载到内存中的运行时类，会缓存一定时间，再次时间之内，可以通过不同的方法获取运行时类。
   
6. ClassLoader是什么

   1. 作用
      1. 将class文件字节码内容加载到内存中，并将这些静态数据转换为方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。
   2. 类缓存
      1. 标准的javase类加载器可以按要求查找类，但一旦这个类被加载到类加载器中，它将维持加载(缓存)一段时间。不过java垃圾回收机制可以回收这些class对象
   3. Bootstrap Classloader： 用c++编写的，是jvm自带的类加载器，负责java平台核心库，用来装载核心类库，该加载器无法直接获取
   4. Extension Classloader：负责jre/lib/ext目录下的jar包或 -D java.ext.dirs指定目录下的jar包装入工作库
   5. System Classloader：负责java -classpath 或-D java.class.path所指的目录下的类，与jar包装入工作，是最常用的加载器
   6. 自定义类加载器

7. 如何创建运行时类的对象？重要

   1. class.newInstance()
      1. 在对应类中有构造器
      2. 有权限
      3. 所以很多时候需要定义空参构造器

   

8. 反射的应用：动态代理

   1. 后续和代理模式一起学习

9. 动态语言和静态语言的区别

   1. 动态语言实质在运行时可以改变其结构的语言：例如新的函数，对象，甚至代码可以被引进，已有的函数可以被删除或是其它结构上的变化。**在运行时代码可以根据某些条件改变自身结构**。主要动态语言：python JavaScript
   2. 静态语言：运行时结构不可变。如：java ， c ， c++
   3. java不是动态语言，但可以称之为准动态语言。java可以利用反射机制，字节码操作获得类似动态语言的特性。

10. new 一个对象到底做了什么？

11. 什么时候用反射？

    1. 在编译时不能确定实例化的是什么，需要使用反射

12. java项目结构

13. 哪些类型可以有class对象

    1. class
    2. interface
    3. 数组
    4. enum
    5. annotation
    6. primitive type
    7. void



#### 第15章

##### lambda表达式√

1. lambda表达式是什么？
   1. 是一个匿名函数，可以吧lambda表达式理解为是一段可以传递的代码。使用他可以写出更简洁，更灵活的代码
   2. 本质是一个函数式接口的实例。
   3. 以前匿名实现类实现的都可以使用lambda表达式
2. lambda表达式的格式？
   1. -> lambda操作符
   2. 左边:lambda形参列表 右边：lambda体(其实就是重写的抽象方法的方法体)
3. 语法格式是什么？
   1. lambda形参列表的参数类型可以省略（类型推断），如果只有一个参数，括号也可以省略
   2. 正常有一个大括号，如果lambda只有一条语句，大括号和return省略

##### 函数式接口

1. 什么是函数式接口？
   1. 如果一个接口中只声明了一个抽象方法， 则此接口称为函数式接口
   2. 可以使用@FunctionInterface注解检验是否是函数式接口
   3. java.util.Function定义了丰富的函数接口

2. java内置四大核心函数式接口
   1. Consumer<T>     void  accept(T t)  接收参数，不返回
   2. BICounsumer(T, U)  void accept(T, U)
   3. Suplier<T>     T get()  无参， 只有返回值
   4. Function<T, R>  R  apply(T)    接受一个参数，并有一个返回值
      1. UnaryOperator <T>  T apply<T> Function 的子类
   5. BiFunction<T, U, R>    R apply(T, U)
      1. BinaryOperator<T,> T appley(T, T)  BIFunction 的子类
   6.  Predicate<T>   boolean test(T t)
   7. BiPredicate<T, U > boolean test(T, U )
3. 转换式函数接口
   1. ToIntFunction<T>  IntFunction<R>
   2. ToLongFunction<T> LongFunction<R>



##### 方法引用/构造器引用

​	什么是方法引用？

​	当要传递给

##### Stream API

##### 接口的增强

##### Optional类

##### 新的时间和日期API





##### 学习的思维方式

1. 大处着眼，小处着手

   



