#### 第八章 多线程

##### 1. 程序，进程，线程

1. 进程和线程的区别
   1. 进程

      进程是资源分配的最小单位，系统运行时会为进程分配不同的内存区域。

   2. 线程

      线程是调度和执行的最小单位，每个线程拥有独立的运行栈和程序计数器。线程切换的开销小

      一个进程中的多个线程共享相同的内存单元/内存地址空间。他们在同一堆中分配对象，可以访问相同的变量个对象。

2. 进程分配的资源都包括什么？

3. 线程的运行栈和程序计数器是什么？

4. 线程创建的开销是什么

5. java的应用程序至少有三个线程，main线程，gc线程，异常处理线程。当发生异常时，会影响主线程

6. 多线程的优点

   1. cpu充分使用，
   2. 多核情况下充分使用cpu



##### 2. *线程的创建和使用*

1. 线程有哪些创建方式？
   1. 继承 Thread 类，重写run()方法。使用start启动。
   
   2. 实现runnable接口，使用Thread包装实现类。使用Thread start方法启动Thread。start方法会判断target是不是为空。
   
   3. 实现callable接口
   
      1. 与实现runable接口的区别
         1. 获取返回值
         2. 可以抛出异常
      2. 实现方法，实现callable接口，然后通过futuretask 类启动线程。futuretask支持对
   
   4. 使用线程池。
   
      ```
      Executors.newFixedThreadPool(10)
      service.submit()
      service.run()
      ```
   
      
   
2. runnable 和 callable的区别

   1. callable可以有返回值
   2. 可以抛出异常
   3. 可以使用泛型

3. runnable和Thread类两种方式的比较？
   1. 推荐使用runnable接口
   2. java是单继承的，使用继承方式会影响继承体系
   3. 同一个runnable实现对象可以传给多个Thread，这样可以使共享数据封装在更小的对象范围内。

4. start方法的作用以及实现？？ 未解决
   1. 启动线程
   2. 调用run方法
   3. 同一个现场只能start一次，在start方法中有状态锁。

5. Thread的常用方法
   1. getName()； setName();
   2. join();在线程a中调用线程b，此时线程a进入阻塞状态，知道线程b完全执行完成以后，线程a才结束阻塞状态。

6. 线程的优先级有多少个，最小是多少，最大是多少，正常线程优先级是什么。

   1. 最高为10，最小为1， 正常为5

7. join实现原理？？

8. java守护线程的用户线程的区别？

   1. 守护线程是服务与用户线程的

##### 3. 线程的生命周期

 1. Thread.State定义了java线程的状态

 2. ```
    new , runnable， block， waitting  timedWaiting ,terminated
    
    新建， 就绪， 运行， 阻塞，死亡
    ```

    ![Screen Shot 2019-09-19 at 10.49.02 AM](Screen Shot 2019-09-19 at 10.49.02 AM-8904588.png)

##### ***4. 线程的同步***

1. java线程同步的方法?
  
   1. 同步代码块
   
      ```
      synchronized(同步监视器){
          //需要同步的代码。
        }
        操作共享数据的代码被称为需要同步的代码。
        
       同步监视器：锁。任何一个类的对象都可以充当为锁。但是必须是同一个锁。
       runnable中可以考虑使用this作为锁
       在继承方式中可以考虑使用当前类作为锁。
      ```
   
   2. 同步方法：非静态同步方法的锁是this。静态的同步方法的锁是当前类本身。
   
      如果操作共享数据的代码完整的声明在一个方法中，可以把该方法生命为同步方法。
   
   3. ReentrantLock
   
2. synchronized和reentrantLock的区别

   1. 自动，手动加锁释放锁。
   2. lock效率更好。

3. Synchronized中锁的对象是如何实现的，synchronized的实现，其实现与lock的区别。

##### 5. 线程的通信

1. 一下三个方法中只能放在同步代码块中和同步方法中，并且调用者必须是同步监视器

   wait  notify 唤醒被wait的线程，多个线程被wait，唤醒优先级高的。 notifyall 唤醒所有wait的方法。

2. sleep和wait的区别

   1. 执行后当前线程都会阻塞
   2. sleep方法则Thread中声明， wait在object中声明
   3. sleep在任何地方都可以使用，wait只能在同步代码块中
   4. sleep不会释放锁，wait会释放锁

3. 实现一个生产者消费者

   1. 生产者
   2. 消费者
   3. channel

#### 第九章 java常用类

##### 1. String 

1. string的底层实现？

   1. String 是final的，不能被继承。
   2. 实现了 Serializable, Comparable接口
   3. 底层是一个不可变的char数组。

2. String str1 = "abc" 与String str2 = new String("abc");的区别

   使用字面量方法声明，临时变量中存储的是常量池中的地址。使用new方法，会先在堆中开辟内存，临时变量指向堆中的地址，堆中分配的内存指向常量池中对应的字符串。

3. String s1 = "a" String s2 ="b" String s3= "ab";  String s4 = s1 + s2;  s5 = s1 + "b" .s4 == s3?  s5 == s3?

   true, false.有变量参与的字符串相加，都会现在堆中开辟内存。

   常量与常量的拼接，直接在常亮池中，且常量池中不会有相同常量的内容。

   只要其中有一个变量，结果就会在堆中。  

4. 字符串在jvm是如何存储的

   1. 字符串常量池。字符串常量池在方法区

5. String与其它类型的转换？

   1. 与基本类型的转换
      1. Integer.parseInt(str1);
      2. String.valueOf(num);
   2. 与char[]之间的转换
      1. String.toCharArray();
      2. String.new(char[] ch)
   3. 与byte[]之间的转换
      1. "".getBytes();可以用参数指定字符集
      2. new String() 同样可以指定编码集

6. String.Intern()方法返回常量池中的地址

7. String, StringBuffer, stringBuilder之间的区别

   1. StringBuffer线程安全的，都是同步方法。可变字符串
   2. StringBuilder非线程安全的，效率更高。可变字符串

   

8. StringBuffer的底层实现和扩容。

   1. 底层创建一个默认长度为指定串+16的数组。
   2. 当长度不够时，创建一个容量为原有容量左移移位并加二容量，并复制原有数组。
   3. StringBuffer可以指定底层数组容量创建。

9. final关键字的实现。

   1. 未解决

10. String为什么要是不可变的？为什么要把String放在常量池中

    

##### 2. 日期和时间

1. Date类(大多数方法已经过时了)

   1. java.lang.System.CurrentMillis()获取时间戳
   2. date可以无参数保存当前时间，也可以使用ms数创建。

2. java.text.simpleDateFormat用于格式化日期输出。

   ```
   SimpleDateFormat  sdf = new SimpleDateFormat(“yyyy-MM-dd”);
   解析：java.util.Date date = sdf.parse(“2017-08-16”);
   
   DateTimeFormatter dtf= DateTimeFormatter.ofPattern(“yyyy-MM-dd”); 
   
   ```

3. Calendar类(抽象类)

   1. Calendar.getInstance();
   2. get/set/add/getTime/SetTime
   3. 月份1月是0.星期 周日是1

4. java.time包

   1. date相关类
      1. 一下三个都是不可变的，设置以后会返回新的。
      2. LocalDate
      3. LocalTime
      4. DlocalDateTime.of()  .now()
   2. instant(类似于date)
   3. DateTimeFormatter (类似于SampleDateFormat)

5. JDK 8之前和JDK8中日期、时间相关的类分别有哪些？

   java.util.Date 和 java.sql.Date  ->  Instant

   SimpleDateFormat  -> DateTimeFormatter

   Calendar  -> LocalDate、LocalTime、LocalDateTime

##### 3 .java比较器

​	Comparable或 Comparator

1. comparable接口
2. Comparator

##### 4. System类

​	表示系统。有很多系统相关方法

​	1. in，out， err。表示输入，输出，错误。

##### 5. Math类

​	关于数学的方法。

##### 6. BigInteger 与BigDecimal

​	BigInteger表示不可变的任意精度的整数。

​	BigDecimal类似，代表浮点型。



##### 

##### 第十章枚举类和注解

##### 枚举类

1. 什么是枚举类，什么时候使用枚举类
   1. 类中的对象个数是确定的，有限的。
   2. 当需要定义一组常亮时，使用枚举类。
2. 如何定义枚举类
   1. 使用enum关键字定义
   2. 使用enum关键字的类继承在java.lang.Enum类
3. Enum类常用方法
   1. values() 列举枚举类的所有状态
   2. valueOf()根据obj名返回枚举对象。
4. 使用enum关键字定义的枚举类实现接口
   1. 直接让枚举类实现方法
   2. 让枚举类里的每一个对象实现接口方法

##### 注解(annotation)

1. 注解概述
   1. 代码里的特殊标记，在编译，类加载，运行时被读取，并执行相应的处理。
2. 常见的注解
   1. 生成文档相关的注解。
   2. 编译时进行格式检查
      1. @override  @ deprecated  @suppressWarnings(抑制编译器警告)
   3. 跟踪代码依赖性，实现替代配置的功能
3. 自定义注解
   1. 声明@interface
   2. 自动继承java.lang.annotation.Annotation接口
   3. 成员变量使用无参数方法来声明
4. 什么是元注解，Retention注解和target注解的作用。
   1. 修饰其它注解的注解
   2. Retention:用于指定注解的生命周期。有三个枚举值source：在编译器扔掉， Class：保留在class中(默认行为)  RunTime ：保留至运行时
   3. Target：由于指定注解可以修饰那种类型。
   4. Documented：表示所修饰的注解在javadoc解析时保留下来
   5. Inherited ： 注解会被子类继承。
5. 利用反射获取注解信息
   1. 学习注解是学习。
6. jdk8中注解的新特性
   1. 可重复注解：@Repeatable()修饰注解。
   2. 类型注解新增两个：增加了泛型类型，类型注解
7. 注解的底层实现？

#### 第十一章 java集合

##### 1. Collection 接口方法

1. 概述集合框架的体系

   ```
   Collection接口： 单列数据，定义了存取一组对象的方法的结合
   	List：元素有序，可重复的集合。
   		vector
   		ArrayList
   		LinkedList
   	Set： 元素无序，不可重复的集合。
   		HashSet
   			LinkedHashSet
   		SortedSet
   			TreeSet
   Map接口：双列数据，保存具有映射关系key-value对的集合。
   		HashMap
   			LinkedHashMap
   		HashTable
   			properties
   		SortedMap
   			TreeMap
   ```

   ![Screen Shot 2019-09-23 at 3.07.44 PM 1](Screen Shot 2019-09-23 at 3.07.44 PM 1-9265700.png)

![Screen Shot 2019-09-23 at 3.09.45 PM](Screen Shot 2019-09-23 at 3.09.45 PM.png)

2. Collection接口的方法。

   1. 15个方法。
   2. add()/addAll(Collection);
   3. size()/isEmpty();
   4. clear();
   5. contains()/containsall();调用equals()方法。
   6. remove()/removeAll(Collection) 需要重写equals()方法。
   7. retainAll(Collection) 获取交集
   8. equals()： 所有集合元素相等则相等。有序的和元素顺序相关。
   9. hashCode() 
   10. 集合转换为数组：toArray(); 数组转集合Arrays.asList(T … a);
   11. Iterator() 返回Iterator实例。每次调用都会返回迭代器方法。

3. Iterator迭代器接口有什么方法？

   1. next()
   2. hasNext()
   3. remove()

   ##### 2. Collection 子接口一：List

   1. ArrayList
   2. LinkedList
   3. Vector

   1. ArrayList, linkedList, Vector的异同
      1. 相同点
         1. 实现了List接口， 存储有序，元素可重复
         2. Vector 和ArrayList 底层都是[]Object数组。
      2. 不同点
         1. ArrayList 非线程安全， Vector线程安全。
         2. ArrayList和Vector底层使用[]Object 数组存储,对于频繁查找使用。
         3. LinkedList 非连续存储，底层使用双向链表存储，对于频繁插入和删除操作使用linkedList
   2. ArrayList的源码分析
      1. jdk7	
         1. 底层存储结构是一个Object[]数组
         2. 构造器
            1. 空参构造器：初始化一个容量为10的数组。
            2. 带容量构造器：直接初始化一个指定容量的底层数组。
         3. 添加操作
            1. 确认容量是否够，如果不够扩容，扩容为当前容量 + 当前容量右移1位(1.5倍)
            2. 复制原有的数组。
      2. jdk8的变化：
         1. 构造器
            1. 空参构造器：赋值为一个长度为0的空数组，不提前分配内存。
         2. 添加操作
            1. 第一次添加操作时，底层创建长度为10的数组，然后添加。
         3. 更节省内存，延迟初始化。

4. LinkedList 源码分析

   1. 底层是一个双向链表。保存First, Last节点
   2. 初始花式 first 和last都为空

5. Vector源码分析

   1. 扩容方式和ArrayList有区别，其它都相同，默认使用长度为10的初始化
   2. 扩容新的容量为2倍。
   3. vector使用的较少。多线程情况下也可以用arrayList解决。

6. ListIterator和 collection Iterator的区别？

   1. ListIterator可以添加元素
   2. ListIterator可以定位当前索引的位置
   3. ListIterator可以双向迭代

   ##### 3. Collection 子接口二：Set

   1. Set接口的结构

      ```
      Set
      	HashSet
      		LinkedHashSet作为HashSet的子类出现，遍历内部顺序时会按照添加时顺序遍历。
      	SortedSet
      		TreeSet：使用红黑树存储，可以按照指定属性排序。
      ```

   2. HashSet的实现

      1. jdk 1.7初始化一个  长度为16的数组， jdk1.8在添加时初始化
      2. 添加
         1. 使用hash值通过散列函数计算出在数组中的位置
            1. 判断此位置是否有元素，如果此位置无元素，则直接添加成功
            2. 如果此位置有元素，则比较hash值，
               1. 如果hash值不相同，则添加成功
               2. 如果hash值相同，则比较equals()方法
                  1. 不相同则添加。
                  2. 相同则添加失败
         2. 在jdk1.7中 新元素链接旧元素，jdk1.8中旧元素链接新元素。
      3. 扩容
         1. 当装填因此大于0.75，则扩容

   3. 向set中添加的元素有什么要求

      1. 必须重写hashCode()方法和queals()方法，相同的对象必须具有相同的散列码。
      2. 对象中用作equal作为比较的Field()，都应该用来计算hashCode().

   4. HashCode()方法的实现？

      1. 在object中的hashCode()方法是一个随机数。

   5. equals()方法的实现?

   6. linkedHashSet()的实现

      1. 在原有的基础上根据每个数据增加了前后数据的指针。

      

   7. HashSet的遍历顺序是什么？

   ##### 4. Map接口

   ##### 5. Collections 工具类