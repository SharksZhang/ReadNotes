# data structure

### 1. List

	1. 链表删除
 	2. 链表插入
 	3. 链表逆序
 	4. 链表求环
 	5. 链表求交点
 	6. 链表合并
 	7. 删除链表的第n个节点
 	8. 链表求中点
 	9. 链表是否回文
 	10. 合并k个链表

#### 2. 二叉树

##### **术语** 

1. 节点的度：一个节点含有的子树的个数称为该节点的度； 
2. 叶节点或终端节点：度为零的节点； 
3. 非终端节点或分支节点：度不为零的节点； 
4. 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 
5. 兄弟节点：具有相同父节点的节点互称为兄弟节点； 
6. 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推； 
7. 树的高度或深度：树中节点的最大层次； 
8. 堂兄弟节点：父节点在同一层的节点互为堂兄弟； 
9. 节点的祖先：从根到该节点所经分支上的所有节点； 
10. 孙：以某节点为根的子树中任一节点都称为该节点的子孙。 
11. 森林：由m（m>=0）棵互不相交的树的集合称为森林； 
12. 满二叉树：一棵深度为k，且有2^k-1 (2的k次方减一)个节点称之为满二叉树 
13. 完全二叉树：完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。

##### 二叉树的性质： 

(1) 在非空二叉树中，第i层的结点总数不超过2^(i-1),i>=1； 

(2) 深度为h的二叉树最多有2^h-1个结点(h>=1)，最少有h个结点； 

(3) 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1；


(4) 具有n个结点的完全二叉树的深度为K =[log2n」+1(取下整数) 

(5)有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若I为结点编号则 如果I>1，则其父结点的编号为I/2； 
如果2*I<=N，则其左儿子（即左子树的根结点）的编号为2*I；若2*I>N，则无左儿子； 如果2*I+1<=N，则其右儿子的结点编号为2*I+1；若2*I+1>N，则无右儿子。 (6)给定N个节点，能构成h(N)种不同的二叉树。h(N)为卡特兰数的第N项。h(n)=C(2*n，n)/(n+1)。 
（7）设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i

2、完全二叉树 
定义：如果一棵二叉树中，只有最下面的两层结点度数小于2，其余各层结点度数都等于2，并且最下面一层的结点，都集中在该层最左边的若干位置上，则此二叉树称为完全二叉树。 
性质1、具有n个结点的完全二叉树的高度k为[log^2n]。 
性质2、对于具有n个结点的完全二叉树，如果按照从上（根结点）到下(叶结点)和从左到右的顺序对二叉树中的所有结点从0开始到n-1进行编号，则对于任意的下标为i的结点，有： 
（1）如果i=0，则它是根结点，它没有父结点；如果i>0,则它的父结点的下标为（i-1）/2。 
（2）如果2i+1<=n-1，则下标为i的结点的左子结点的下标为2i+1；否则，下标为i的结点没有左子结点。 
（3）如果2i+2<=n-1，则下标为i的结点的右子结点的下标为2i+2；否则，下标为i的结点没有右子结点。 

3、满二叉树 
定义：如果一棵二叉的任何结点或者是树叶，或有两棵非空子树，则此二叉树称作满二叉树。 

性质在满二叉树中，叶结点的个数比分支结点个数多1。



#### 知识点

二叉树是否对称

两个二叉树相同

### 2. sort

#### 2.1 bubble sort

#### 2.2 quick sort

注意边界

#### 2.3 insertion sort

#### 2.4shell sort



#### 2.5 select sort

#### 2.6 heap sort

再简单总结下堆排序的基本思路：

　　**a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;**

　　**b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;**

　　**c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。**

#### 2.7 merge sort

### 3. dynamic programming

##### 3.1 动态规划的主要类型：

1. 计数
2. 求最大最小值
3. 求存在性

#### 3.2 动态规化问题的基本步骤

1. 确定状态

   1. 最后一步
   2. 子问题

2. 转移方程

3. 初始条件和边界情况

4. ###### 计算顺序

#### 3.3 dp notes

[notes](./dataStructure.pdf)

[dynamic programming2 notes](./MIT6_006F11_lec20.pdf)

#### 3.3. 1 dynamic programming 1

Summary
* DP ≈ \careful brute force"
* DP ≈ guessing + recursion + memoization
* DP ≈ dividing into reasonable # subproblems whose solutions relate | acyclicly |
usually via guessing parts of solution.
* time = # subproblems × time/subproblem
* DP ≈ shortest paths in some DAG

Memoized DP Algorithm

Bottom-up DP Algorithm

Fibonacci Numbers

Shortest Paths

#### 3.3.2 dynamci programming2

##### Lecture Overview

• 5 easy steps
• Text justification
• Perfect-information Blackjack
• Parent pointers



### 图

#### 异或

性质

```
1. 交换律 
2、结合律（即(a^b)^c == a^(b^c)） 
3、对于任何数x，都有x^x=0，x^0=x 
4、自反性 A XOR B XOR B = A xor 0 = A
```

使用异或的性质可以求 唯一奇数个数和唯一偶数个数

#### 二叉查找树

1. 查找
2. 插入
3. 删除(未完成)

#### 散列表

散列函数

1. 直接定址法
2. 数字拆分法
3. 平方取中法
4. 折叠法
5. 除留余数法
6. 随机数法

散列冲突：

1. 开放定址法
   1. 线性探测法
   2. 二次探测法

2. 再散列函数
3. 链地址法
4. 公共溢出法

实现字节的hash表

使用场景：

1. 字符哈希
2. 哈希表排序
3. 哈希表厂最好为质数