1. 为什么要写质量高的代码？
   1. 利润 = 收益 - 成本
   2. 站在程序员角度，我们将成本分为内在成本和偶发成本，内在成本为实现一个功能必须要的成本，偶发成本为额外的成本。
      1. 如果实现一个功能，所有已有的代码可重用的越少，那么开发人员所需要的成本越高
      2. 如果代码可读性越差，实现新功能的成本越高
      3. 如果代码的冗余部分太多，导致维护冗余代码的成本也会越来越多
   3. 这些偶发成本会随着越来越恶化而成指数级增长，知道我们开发一个新的功能的成本已经大于这个功能本身创造的收益，则这个项目会被取消。
2. 如何写出高质量的代码
   1. 可重用
   2. 可读性号
   3. 没有冗余
3. 如何提高可重用性
   1. 高内聚，低耦合
   2. 高内聚：
      1. 紧密关联的事务应该在一起
      2. 只有紧密关联的事务应该在一起
   3. 低耦合：如何耦合度高，重用当前功能会引入其它的理解成本
4. 在项目中如何做到高内聚，低耦合
   1. 模块化过程中， 模块内部应该高内聚，
   2. 定义模块之间的api时，应该让他们低耦合
   3. 正交设计四原则
      1. 消除重复：如果有重复代码，重复代码本身就是相同部分，却放在了不同地方，没有高内聚
      2. 分离不同的变化方向：当你发现需求导致一个变化方向出现时，将其从原有的设计中分离出去。不同的功能放在不同的模块，低耦合，高内聚
      3. 缩小依赖范围：
         1. API 应包含尽可能少的知识。因为任何一项知识的变化都会导致双方的变化;知识越少，耦合度越低
         2. api应该高内聚，不应该强迫客户依赖它不需要的东西
      4. 向着稳定的方向依赖
         1. 同时也是低耦合
5. 正交设计四原则和solid五原则的关系
   1. 消除重复 ： 单一职责
   2. 分离关注点： 单一职责， 开闭原则
   3. 缩小依赖范围： 接口分离原则
   4. 向稳定的方向依赖: 里氏替换原则 和 依赖倒置原则
6. 所有的问题解决都是不可能一次到位的，随着对这个知识的理解，我们对问题域的理解，对需求的理解，以及需求的改变，这就需要我们不断的重构我们的代码
   1. 重构的时机
      1. 事不过三
      2. 准备性重构
      3. 理解性重构
      4. 捡垃圾式重构
   2. 识别代码坏味道，掌握重构的手法
   3. 重构的基本手法
      1. rename， extract， inline， move
   4. 原子步骤
      1. set up： create， copy， modify， build
      2. subsitute: replace test
7. 重构是需要测试用例的，此时又需要tdd，
   1. tdd的基本理论
      1. 除非是为了使一个失败的 unit test 通过，否则不允许编写任何产品代码
      2. 在一个单元测试中，只允许编写刚好能够导致失败的内容（编译错误也算失败）
      3. 只允许编写刚好能够使一个失败的 unit test 通过的产品代码
   2. 违反了会怎么样
      1. 违反了第一条，产品代码没有测试保护
      2. 违反了第二条，保证小步快跑，步子太大，会增加压力
      3. 我烦第三条，类似第一条
   3. 基本步骤
      1. 拆分任务列表
      2. 写测试
      3. 实现
      4. 重构
   4. tdd难点
      1. 不会写测试
      2. 不会重构
      3. 不会设计高内聚低耦合的代码。

​	