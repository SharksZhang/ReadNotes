##策略模式
##1.定义
定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户
####1.1通用类图
####1.2通用代码
```java
package com.itfish.strategy.general;

public class Context {
    private Strategy strategy;

    public static void main(String[] args) {

        Context context = new Context(new ConcreteStrategy());
        Context context1 = new Context(new ConcreteStrategy1());
        context.doAnyThing();
        context1.doAnyThing();
    }
    public Context(Strategy strategy){
        this.strategy =strategy;
    }
    public void doAnyThing(){
        this.strategy.doSomething();
    }
}

```

``` java
package com.itfish.strategy.general;

public interface Strategy {
    public void doSomething();
}

```


``` java
	public class ConcreteStrategy1 implements Strategy{
    @Override
    public void doSomething() {
        System.out.println("ConcreteStrategy1");
    }
}
```

``` java
	public class ConcreteStrategy1 implements Strategy{
    @Override
    public void doSomething() {
        System.out.println("ConcreteStrategy1");
    }
}
```
##2.优缺点
####2.1策略模式的优点
#####2.1.1算法可以自由切换
这是策略模式本身定义的，只要实现抽象策略，它将成为策略家族的一个成员，通过封装角色对其进行封装，保证对外提供可自由切换的策略。
#####2.1.2避免使用多重条件判断
由其它模块决定采用何种策略，策略家族对外提供的访问家口就是封装类，简化了操作，同时避免了条件语句判断。
#####2.1.3扩展性良好
新增一个策略，只需要增加一个实现类
####2.2策略模式的缺点
#####2.2.1策略类数量增多
每一个策略都是一个类，复用的可能性很小，类数量增多。
#####2.2.2所有的策略类都需要对外暴露
上层模块必须知道有哪些策略，才能决定使用哪一个策略。（可以用其它模式修改这个缺陷）


##3.使用场景
####3.1 多个类只有在算法和行为上稍有不同的场景

####3.2 算法需要自由切换的场景
算法选择由使用这决定，或者算法始终在进化，
####3.3 需要屏蔽算法规则的场景


##4.注意事项
如果系统中策略家族的具体策略数量超过四个，则需要使用混合模式，解决策略类膨胀和对外暴露的问题。否则日后的系统维护就会成为一个烫手山芋。
##5..代码示例
####5.1使用场景1举例
制造鸭子，各种鸭子的飞行方式和叫声不同。
#####5.1.2 分析
- 如果使用继承：会导致所有的子类都具有该方法，对于不会飞的鸭子来说，继承是不对的
- 定义接口：会导致代码不能复用，所有的子类都必须实现方法。


#####5.1.2 类图

#####5.1.3 代码示例

``` java
package com.itfish.strategy.duckFactory;

public abstract class Duck {
    FlyBehavior flyBehavior;
    QuackBehavior quackBehavior;
    public Duck(){
    }
    public abstract void display();
    public void performFly(){
        this.flyBehavior.fly();
    }
    public void performQuack(){
        this.quackBehavior.quack();
    }
}

```

``` java


public interface FlyBehavior {
    public void fly();
}

public interface QuackBehavior {
    public void quack();
}




```

``` java
public class FlyNoWay implements FlyBehavior {
    @Override
    public void fly() {
        System.out.println("fly no way");
    }
}

public class FlyWithWings implements FlyBehavior{
    @Override
    public void fly() {
        System.out.println("fly with wings");
    }
}
```


``` java

public class Quack implements QuackBehavior {
    @Override
    public void quack() {
        System.out.println("Quack");
    }
}

public class MuteQuack implements QuackBehavior{
    @Override
    public void quack() {
        System.out.println("Mute");
    }
}

public class Squeak implements QuackBehavior{
    @Override
    public void quack() {
        System.out.println("Squeak");
    }
}


```

```java
public class ModelDuck extends Duck{
    public ModelDuck(){
        this.flyBehavior = new FlyNoWay();
        this.quackBehavior = new MuteQuack();
    }

    @Override
    public void display() {
        System.out.println("I am a model duck");
    }
}

public class RedHeadDuck  extends Duck{
    public RedHeadDuck(){
        this.quackBehavior= new Quack();
        this.flyBehavior = new FlyNoWay();
    }
    @Override
    public void display() {
        System.out.println("I am red head duck");
    }

}

public class RubberDuck extends Duck {

    public RubberDuck (){
        this.flyBehavior = new FlyNoWay();
        this.quackBehavior = new Squeak();
    }
    @Override
    public void display() {
        System.out.println("i am RubberDuck");
    }
}

```
#####5.1.4 总结
- 在本例中，Duck类为通用代码中的context类。
- FlyBehavior和QuackBehavior为StrategyInterface。
- FlyNoWay，FlyWithWings 为FlyBehavior策略的实现。
- Squeak,Quack,MuteQuack为QuackBehavior策略的实现
- ModelDuck，RedHeadDuck，RubberDuck看做是调用算法的客户






##6.设计原则
在5.1示例中，使用了一下设计原则。
- 把会变化的取出并封装起来，好让其它部分不受影响。
- 针对接口编程，而不是针对实现。
- 多用组合，少用继承。
首先，从超类中找出了变化的和不变的部分。变化的部分未fly和quack。将其从超类中拿出来。其次，使用接口屏蔽变化，将不变的封装在超类中，将变化的另外实现。最后使用fly和quack组合出鸭子的行为，可以在运行时动态改变。

