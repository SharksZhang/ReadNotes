1. 计算机网络的体系结构？在tcp/ip中如何划分
    1. 物理层， 数据链路层， 网络层， 传输层， 会话层， 表示层， 应用层
    2. tcp/ip:网络接口层 网际层，传输层，应用层
 2. 数据链路层解决的基本问题是什么？
     1. 封装成帧：把网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束
     2. 透明传输：帧使用首部和尾部进行定界，如果帧的数据部分和首尾部相同，则进行转义，在接收端接收端进行处理后还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。
     3. 差错检测：通过CRC来检查bit差错
3. CSMA/CD 协议是什么
   1. CSMA/CD表示载波监听多点接入/碰撞检测
      1. **多点接入** ：说明这是总线型网络，许多主机以多点的方式连接到总线上。
      2. **载波监听** ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。
      3. **碰撞检测** ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。
4. 以太网帧的格式是什么样的？最大最小长度是多少
   1. 以太网帧格式： 目的地址，原地址，类型， IP数据包 差错校验
   2. ![img](164944d3-bbd2-4bb2-924b-e62199c51b90.png)
5. 交换机的自学习能力是如何实现的？
   1. 交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。
   2. 交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。

6. ip数据报的格式，以及提供的功能
   1. 网络层向上层提供简单灵活，无连接，尽最大努力交付的数据包服务服务。
   2. 屏蔽底层网络的差异：使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。
   3. ip头部提供的功能路由，分片，首部校验
   4. 20个固定字节  
      1. 长度： 版本 首部长度， 总长度
      2. 分片功能：标识， 标志（MF：标识还有分片 DF：不要分片）， 片偏移
      3. 路由和校验功能： 生存时间，协议，首部校验和
      4. 原地址
      5. 目的地址

![img](85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg)

7. 什么是ARP协议？

   ARP 实现由 IP 地址得到 MAC 地址。

   每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。

   如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。

8. 广播风暴如何出现？

   广播风波是因为以太网中出现了明环或暗环，引起广播包被指数涨速递增，整个网络流量被广播所占据，其它的转发业务不能进行。

   以太网交换机对广播包的处理，是不管从哪个端口收到广播包，都完整地复制一份转发到其它端口，如果环路，就会无限复制。

9. 网际控制报文协议 ICMP多作用？都有什么应用？

   1. ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。

   2. ICMP 报文分为差错报告报文和询问报文。

      1.  Ping

         1. Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。

            Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。

      2. Traceroute 

         1. Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。
            - 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；
            - 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。
            - 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。
            - 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。

10. 路由器分组转发流程？

    1. 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。
    2. 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；
    3. 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；
    4. 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；
    5. 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；
    6. 报告转发分组出错。

11. 路由选择协议都有哪些？分别是如何工作的？

    1. 可以把路由选择协议划分为两大类：

       1. 自治系统内部的路由选择：RIP 和 OSPF
       2. 自治系统间的路由选择：BGP

    2. Rip

       RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。

       RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。

       距离向量算法：

       - 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；
       - 对修改后的 RIP 报文中的每一个项目，进行以下步骤：
       - 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；
       - 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。
       - 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。

       RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。

    3. 内部网关协议 OSPF

       开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的

       OSPF 具有以下特点：

       - 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。
       - 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。
       - 只有当链路状态发生变化时，路由器才会发送信息。

       所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。

    4.  外部网关协议 BGP
    
   1. 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。
     
     

​	

12. UDP和Tcp的区别

    1. UDP 是面向无连接的，尽最大可能交付。TCP是面向连接的提供可靠交付。
    2. UDP没有拥塞控制，Tcp有流量控制，拥塞控制。
    3. UDP是面向报文(对于应用程序传下来的报文不合并也不拆分，知识添加UDP首部)，Tcp提供全双工通信，面向字节流(把应用层传下来的报文看成字节流，把字节流组织称大小不等的数据块)
    4. UDP支持一对一，一对多，多对一，和多对多的交互通信。每一条TCP连接只能是点对点的（一对一）。

13. UDP的首部格式是什么？

    1. 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

       ![img](d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg)

14. TCP 首部格式
    1. 20字节的固定长度
       1. 源端口，目的端口
       2. 序号
       3. 确认号
       4. 数据偏移，确认ACK，同步SYN，终止 FIN ，窗口
       5. 检验和，紧急指针
    2. ![img](55dc4e84-573d-4c13-a765-52ed1dd251f9.png)

15. TCP三次握手过程？为什么要进行第三次握手？

    1. 假设 A 为客户端，B 为服务器端。

       - 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
       - A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
       - B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
       - A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
       - B 收到 A 的确认后，连接建立。

    2. ![img](e92d0ebc-7d46-413b-aec1-34a39602f787.png)

    3. 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

       客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

16. TCP的四次挥手过程，TIME_WAIT的原因

    1. 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

       - A 发送连接释放报文，FIN=1。
       - B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
       - 当 B 不再需要连接时，发送连接释放报文，FIN=1。
       - A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
       - B 收到 A 的确认后释放连接。

       **四次挥手的原因**

       客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

       **TIME_WAIT**

       客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

       - 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
       - 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

    ![img](f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg)

17. TCP可靠传输是如何是如何实现的？
    1. TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

       一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：

       [![img](https://camo.githubusercontent.com/02e9a4a23b05bcf814d9e5d0c1b79a6bb5ae2aee/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f525454733d28312d61292a2852545473292b612a525454)](https://camo.githubusercontent.com/02e9a4a23b05bcf814d9e5d0c1b79a6bb5ae2aee/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f525454733d28312d61292a2852545473292b612a525454)

       其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。

       超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：

       [![img](https://camo.githubusercontent.com/da3da0a6cad7ef2af7d7adcd2940277780c35325/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f52544f3d525454732b342a5254545f64)](https://camo.githubusercontent.com/da3da0a6cad7ef2af7d7adcd2940277780c35325/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f52544f3d525454732b342a5254545f64)

       其中 RTTd 为偏差的加权平均值。

       

18. TCP的流量控制是什么？如何实现的？

    1. 流量控制是为了控制发送方发送速率，保证接收方来得及接收。

       接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

    2. 滑动窗口原理

       1. 窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

          发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

          接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

          ![img](a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg)

19. TCP是如何做拥塞控制控制的？

    如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

    ![img](910f613f-514f-4534-87dd-9b4699d59d31.png)

    1. TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

       发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

       1. 慢开始与拥塞避免

          发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

          注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

          如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

       2. 快重传与快恢复

          在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

          在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

          在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

          慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

          ![img](f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png)

20. DHCP协议？

    1. DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。

       DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。

       DHCP 工作过程如下：

       1. 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。
       2. DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。
       3. 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。
       4. DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。

       [![img](https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/23219e4c-9fc0-4051-b33a-2bd95bf054ab.jpg)](https://github.com/CyC2018/CS-Notes/blob/master/notes/pics/23219e4c-9fc0-4051-b33a-2bd95bf054ab.jpg)

21. 常用端口有哪些

|                  |        |         |         |                             |
| ---------------- | ------ | ------- | ------- | --------------------------- |
| 域名解析         | DNS    | 53      | UDP/TCP | 长度超过 512 字节时使用 TCP |
| 动态主机配置协议 | DHCP   | 67/68   | UDP     |                             |
| 简单网络管理协议 | SNMP   | 161/162 | UDP     |                             |
| 文件传送协议     | FTP    | 20/21   | TCP     | 控制连接 21，数据连接 20    |
| 远程终端协议     | TELNET | 23      | TCP     |                             |
| 超文本传送协议   | HTTP   | 80      | TCP     |                             |
| 简单邮件传送协议 | SMTP   | 25      | TCP     |                             |
| 邮件读取协议     | POP3   | 110     | TCP     |                             |
| 网际报文存取协议 | IMAP   | 143     | TCP     |                             |

22. web页面请求过程。

    1.   DHCP 配置主机信息

       - 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。
       - 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。
       - 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。
       - 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。
       - 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。
       - 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。
       - 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。

     2.   ARP 解析 MAC 地址
   - 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。
       - 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。
       - 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。
       - 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。
       - DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。
       - 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。
       - 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。

3.   DNS 解析域名
       - 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。
   - 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。
       - 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。
       - 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。
       - 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。
   
     4.   HTTP 请求页面
   - 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。
     
       - 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。
   - HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。
       - 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。
       - HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。
       - 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。
   
    23. URI，URL， URN的区别
   
        1. URI（Uniform Resource Identifier）统一资源标识符包含URL和URN
        2. URL(Uniform Resource locator) 统一资源定位符 https://www.google.com
        3. URN(Uniform Resource Name)统一资源名称
   
    24. http 请求报文和响应报文的格式是什么？
   
        1. 请求报文
   
           1. Request Message Header
              1. Request Line
              2. Request Headers
           2. 空行
           3. Request Message Body
   
           ![img](HTTP_RequestMessageExample.png)
   
        2. 响应报文
   
           1. Response Message Header
              1. Status Line
              2. Response Header
           2. 空行
           3. Response Message Body
   
        ![img](HTTP_ResponseMessageExample.png)
   
25. http都有哪些方法？
    1. GET：获取资源
    2. HEAD：获取报文首部 ，和 GET 方法类似，但是不返回报文实体主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。
    3. POST :传输实体主体,POST 主要用来传输数据，而 GET 主要用来获取资源。
    4. PUT:更新资源，具备幂等性
    5.  PATHCH：对资源进行部分修改，PUT也可以用于修改资源，但是只能完全替代原始资源，patch允许部分修改
    6. Delete  : 删除资源
    7. OPTIONSs查询支持的方法

5. HTTP状态码都有哪些

   1. 1XX(信息性状态码) 接收的请求正在处理

      1. **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

   2. 2XXSuccess(成功状态码)

      1. 200 Ok
      2. 204 no content:请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
      3. 206 Partial Content:表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

   3. 3XX Redirection(重定向状态码)(浏览器自动重定向到一个url)

      1. 301 Moved permanently:永久性重定向 01表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），**搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址**；

      2. 302 Found:临时性重定向这个重定向只是临时地从旧地址A跳转到地址B，**搜索引擎会抓取新的内容而保存旧的网址。**

         

   4. 4XX Client Error(客户端错误状态码)

      1. 400 Bad Request: 请求报文中存在语法错误
      2. 401 Unauthorized:请求需要认证信心
      3. 403 Forbidden: 请求被拒绝
      4. 404 Not fount

   5. 5XX Server Error(服务端错误状态码)

      1. 500 Internal Server Error:服务器在执行请求是发生错误
      2. 503 Service  Unavaliable:服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

   

6.   http存在的风险

   1.   所以 HTTP 传输面临的风险有：

      （1） 窃听风险：黑客可以获知通信内容。

      （2） 篡改风险：黑客可以修改通信内容。

      （3） 冒充风险：黑客可以冒充他人身份参与通信。

7. 什么是https？https加密方式？

   HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。

   1. 客户端向服务器端请求，服务器返回ssl证书，用于识别服务器端的合法性，证书中包含公钥
   2. 得到公钥后使用非对称加密传输后续对称加密的秘钥
   3. 后续使用对称加密的秘钥进行传输。

8. http和https的区别

   1. http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：
   2. 端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；
   3. 资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；
   4. 开销：Https通信需要证书，而证书一般需要向认证机构购买；
      　
      Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。

9. 对称加密与非对称加密的区别和原理？

   1. 对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。
   2. 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

10. get 和post的比较

   1. GET 用于获取资源，而 POST 用于传输实体主体。
   2. GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中
   3. get是安全的，不会改变服务器状态，而post会
   4. get是幂等性的，post不是

11. Session 与 Cookie 的对比

    实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；

    大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；

    安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；

    服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。



34. tcp的粘包问题

    1. 粘包问题本质是 tcp是面向字节流的，会重新封装包，而udp会对每个数据进行封装。 

35. tcp的长短连接

    1. **TCP 本身并没有长短连接的区别** ，长短与否，完全取决于我们怎么用它。
       - 短连接：每次通信时，创建 Socket；一次通信结束，调用 socket.close()。这就是一般意义上的短连接，短连接的好处是管理起来比较简单，存在的连接都是可用的连接，不需要额外的控制手段。
       - 长连接：每次通信完毕后，不会关闭连接，这样可以做到连接的复用。 **长连接的好处是省去了创建连接的耗时。**

36. HTTP的长连接和短连接的区别

    当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

    长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

    - 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 `Connection : close`；
    - 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 `Connection : Keep-Alive`。

37. http各个版本之间的区别

    1. http 1.0默认为短连接
    2. http 1.1
       1. 默认长连接
       2. 新增put patch options delete方法
       3. 同一个tcp连接里面，数据通信是串行的
    3. http 2
       1. 复用tcp连接，在一个链接里，可以同时发送多个请求和回应，且不用按顺序
       2. 服务器主动推送
       3. 解析基于二进制，传输更高效
       4. 报头压缩，降低开销

38. tcp保活功能（KeepAlive）？

    保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。

    1. 首先想到的是 TCP 中的 KeepAlive 机制。KeepAlive 并不是 TCP 协议的一部分，但是大多数操作系统都实现了这个机制（所以需要在操作系统层面设置 KeepAlive 的相关参数）。KeepAlive 机制开启后，在一定时间内（一般时间为 7200s，参数 `tcp_keepalive_time`）在链路上没有数据传送的情况下，TCP 层将发送相应的 KeepAlive 探针以确定连接可用性，探测失败后重试 10（参数 `tcp_keepalive_probes`）次，每次间隔时间 75s（参数 `tcp_keepalive_intvl`），所有探测失败后，才认为当前连接已经不可用。

39. http如何解决tcp分包问题
    1. 使用content-length字段
    2. 使用固定长度，分块传输
40. tcp解决粘包的几种方法
    1. 定长传输
    2. 变长传输
       1. 使用定界符
       2. 开始传输时传输包长度
41. 数据包在内核中的路径
42. 建立一个socket的步骤
    1. socket是什么
       1. socket是对 打开open –> 读写write/read –> 关闭close”这种模式的抽象
    2. socket()函数
       1. socket()用于创建一个socket描述符()它唯一标识一个socket。这个socket描述跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。
       2. socket函数参数
          1. domain：协议族决定了socket的地址理性
          2. type：指定socket类型。
          3. protocol：指定协议
       3. 当我们调用socke时，返回的socket描述它存在于协议族