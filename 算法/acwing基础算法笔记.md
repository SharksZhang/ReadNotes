## acwing基础算法笔记

### 动态规划

dp的优化一般是对动态规划方程或者动态规划代码进行等价变形。所以一般先把最基本的形式写出来，然后再优化。

1. 状态表示
   1. 集合
      1. 所有宣发
      2. 条件
         1. 只从
   2. 属性：最大，最小，数量

2. 状态转移方程
3. 具体代码步骤
   1. 初始状态
   2. for循环进行状态转移
   3. 过滤不存在状态
4. 动态规划的划分
   1. 倒数第二个数

#### 5. 背包问题

n个物品和容量为v的背包，每个物品有两个属性，体积vi  价值    w表示价值。在能装下的情况下，总价值最大。

1. 背包问题一般是两维。
2. 背包问题的集合
   1. 只从i个物品中选
   2. 选出的物品总体积小于j
   3.  用 f(i, j)表示集合中价值的最大值
3. 状态计算：对应的是集合的划分。

##### 5.1 01背包问题

状态计算：f(i, j)  =max( f(i-1,j ), f(i -1, j-v[i]) +wi)

每件物品最多用一次。

解法：

1. 注意状态计算的第二种情况只有 j> v[i]时才能力
2. 注意  v[i]数组和方程中下标的对应关系
3. 优化
   1. 优化二维数组为一维数组
   2. 优化可以删除if
   3. 优化计算顺序

##### 5.2完全背包问题

每件物品可以使用无限次。

f(i, j)  =max( f(i-1,j ), f(i , j-k*v[i]) +k*wi)

f(i, j) = max(f(i-1, j), f(i, j-v)+w)

f(j) = max(f(j), f(j-v) +w);

##### 5.3多重背包

每个物品最多有 si个。

f(i, j)  =max( f(i-1,j ), f(i , j-k*v[i]) +k*wi)  0<=k<=s[i]

##### 5.4分组背包

物品有n组，每组中有若干个。每一个组只能选一个。

#### 线性DP

状态转移方程是一个n维的线性顺序。

考虑维数从下向大考虑

##### 300. Longest Increasing Subsequence

此问题可以通过记录从哪个状态转移过来输出序列

#### 区间DP

状态转移：

​	分类：分割的位置

#### 计数类DP

整数划分，可以转换为完全背包问题。

#### 数位统计DP

分情况讨论

#### 状态压缩DP

#### 树形DP

#### 记忆化搜索(实现方式)

### 第一章 基础算法

学习方法：

1. 上课理解思想，
2. 课下：背诵模板(提高最快的方法)
3. 课下： 用模板题练习模板

如何提高熟练度：

1. 模板题题连续重复3-5遍

####  排序

##### 1. 快速排序

1. 思想：(分治) 不稳定
   1. 确定分界点：q[l] q[(l+r/2)] q[r] 随机，四种
   2. 调整区间  ： 左边 区间<= x 右边区间>=x  (最难的一步)
   3. 递归处理两端
2. 算法步骤
   1. 边界值递归退出
   2. 初始化分界点， i，j 指针
   3. 调整分区
   4. 递归

##### 2. 归并排序

1. 思想(分治)
   1. 找分界点  ：下边中间位置
   2. 递归，排序left， right
   3. 归并— 合二为一
2. 代码步骤
   1. 递归出口
   2. 找中点
   3. 递归
   4. 归并

#### 二分

##### 1. 整数二分

​	二分的本质：

 1. 有单调性必然可以二分，没单调性也可以二分

 2. 整数二分的本质是，在一个区间内部，二分边界，每次都要选择答案所在的区间进行二分，最终二分到长度为1的点就是答案的点。二分一定是有解的

    算法步骤

    1. 找中间值

	3. 代码步骤

    1. 先写check 函数(包含答案的区间)
    2. 思考如何根据check函数更新区间， check 是真时，如果是 l=mid 这mid = (l+r+1)/2

##### 2. 浮点数二分

#### 高精度

​	java有高精度的实现。

1. 存储，使用数组存储。



#### 前缀和

1. 如何求s[i]
2. s[i] 有什么作用
   1. 快速求某一段的和

#### 双指针

核心思想：用某种性质将o(n2)的算法优化到O(n)

1. 两个指针 指向两个序列
2. 两个指针指向同一个序列
3. 三指针算法
4. 窗口

#### 位运算

1. n的二进制表示中第k位是几
   1. 先把第k位一道最后一位  n<<k
   2. 看k位是什么
   3. n >> k & 1
2. lowbit(n) = n & -n 返回最后一位1的位置，返回的是最后一个1的数字
   1. x&-x ：x &x取反加1
3. 异或
   1. 交换律 
      2、结合律（即(a^b)^c == a^(b^c)） 
      3、对于任何数x，都有x^x=0，x^0=x 
      4、自反性 A XOR B XOR B = A xor 0 = A
4. n && 1 === 1 则表示n为奇数，否则为偶数
5. n & (n - 1) 可以消除 n 最后的一个1
6. n & (n - 1) === 0 表示 n为2的幂次方



#### 整数离散化

1. 去重
2. 如何算出x离散化的值

#### 区间和并

1. 快速的把有交集的区间合并
2. 步骤
   1. 按照区间左端点排序
   2. 每次维护左右端点，
      1. 右端点小于 当前区间的左端点，则加入结果
      2. 右端点 大于等于当前区间的 左端点， 则右端点取 最大值
3. 和区间有关的问题很多，大部分都是用贪心做，按照左端点或者右端点排序

## 数据结构

#### 链表

1. 单链表
   1. 邻接表
      1. 存储图
      2. 存储树
2. 双链表
   1. 优化某些问题

##### kmp字符串

1. 暴力做法
   1. 
2. 如何优化

##### trie树

1. 高效地存储和查找字符串集合的数据结构
2. 

##### 并查集

1. 作用
   1. 将两个集合合并
   2. 询问两个元素是否在一个集合当中
2. 原理
   1. 每个集合用一棵树来表示。树根的编号就是整个集合的编号，每个节点存储它的父节点，p[x] 表示x的父节点

##### 堆

1. 基本操作
   1. 插入一个数
      1. heap[++size] = x;up(size);
   2. 求集合当中的最小值
      1. heap[1]
   3. 删除最小值：删除第一个元素需要移动所有元素，所以删除最后一个节点
      1. heap[1] = heap[size]; size—;
      2. down(1)；
   4. 删除任意一个元素
      1. heap[k] = heap[size]; size—;down(); up();
   5. 修改任意一个元素
      1. heap[k] = x; down(k); up(k);
2. 堆的结构
   1. 堆是一个完全二叉树
   2. 每个点都是小于等于左右节点的
3. 堆得存储
   1. 一维数组, 从0开始
   2. x的左儿子为 2x + 1
   3. x的右儿子是 2x + 2
4. 两个基本操作
   1. down
   2. up





##### hash表

1. hash表的存储结构
   1. 开放寻址法
   2. 拉链法
2. 字符串hash的方式

#### 搜索与图论

##### dfs

##### bfs

##### 树与图的存储

##### 树与图的深度优先遍历

##### 树与图的宽度优先遍历

##### 拓扑排序

#### java常用操作

1. 二维数组排序

   ```
   		int[][] m = {{1,3},{2,6},{15,18}, {8,10}};
   		Arrays.sort(m, Comparator.comparingInt(x -> x[0]));
   ```

2. 复制数组

   ```
   Arrays.copyOf(nums, length);
   ```

3. 格式化保留几位小数

   ```
   new java.text.DecimalFormat("#.000000").format(l)
   ```

   

