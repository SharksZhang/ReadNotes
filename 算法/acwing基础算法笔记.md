## acwing基础算法笔记

### 动态规划

dp的优化一般是对动态规划方程或者动态规划代码进行等价变形。所以一般先把最基本的形式写出来，然后再优化。

1. 状态表示
   1. 集合
      1. 所有宣发
      2. 条件
         1. 只从
   2. 属性：最大，最小，数量

2. 状态转移方程
3. 具体代码步骤
   1. 初始状态
   2. for循环进行状态转移
   3. 过滤不存在状态
4. 动态规划的划分
   1. 倒数第二个数

#### 5. 背包问题

n个物品和容量为v的背包，每个物品有两个属性，体积vi  价值    w表示价值。在能装下的情况下，总价值最大。

1. 背包问题一般是两维。
2. 背包问题的集合
   1. 只从i个物品中选
   2. 选出的物品总体积小于j
   3.  用 f(i, j)表示集合中价值的最大值
3. 状态计算：对应的是集合的划分。

##### 5.1 01背包问题

状态计算：f(i, j)  =max( f(i-1,j ), f(i -1, j-v[i]) +wi)

每件物品最多用一次。

解法：

1. 注意状态计算的第二种情况只有 j> v[i]时才能力
2. 注意  v[i]数组和方程中下标的对应关系
3. 优化
   1. 优化二维数组为一维数组
   2. 优化可以删除if
   3. 优化计算顺序

##### 5.2完全背包问题

每件物品可以使用无限次。

f(i, j)  =max( f(i-1,j ), f(i , j-k*v[i]) +k*wi)

f(i, j) = max(f(i-1, j), f(i, j-v)+w)

f(j) = max(f(j), f(j-v) +w);

##### 5.3多重背包

每个物品最多有 si个。

f(i, j)  =max( f(i-1,j ), f(i , j-k*v[i]) +k*wi)  0<=k<=s[i]

##### 5.4分组背包

物品有n组，每组中有若干个。每一个组只能选一个。

#### 线性DP

状态转移方程是一个n维的线性顺序。

考虑维数从下向大考虑

##### 300. Longest Increasing Subsequence

此问题可以通过记录从哪个状态转移过来输出序列

#### 区间DP

状态转移：

​	分类：分割的位置

#### 计数类DP

整数划分，可以转换为完全背包问题。

#### 数位统计DP

分情况讨论

#### 状态压缩DP

#### 树形DP

#### 记忆化搜索(实现方式)

### 第一章 基础算法

学习方法：

1. 上课理解思想，
2. 课下：背诵模板(提高最快的方法)
3. 课下： 用模板题练习模板

如何提高熟练度：

1. 模板题题连续重复3-5遍

####  排序

##### 1. 快速排序

1. 思想：(分治) 不稳定
   1. 确定分界点：q[l] q[(l+r/2)] q[r] 随机，四种
   2. 调整区间  ： 左边 区间<= x 右边区间>=x  (最难的一步)
   3. 递归处理两端
2. 算法步骤
   1. 边界值递归退出
   2. 初始化分界点， i，j 指针
   3. 调整分区
   4. 递归

##### 2. 归并排序

1. 思想(分治)
   1. 找分界点  ：下边中间位置
   2. 递归，排序left， right
   3. 归并— 合二为一
2. 代码步骤
   1. 递归出口
   2. 找中点
   3. 递归
   4. 归并

#### 二分

##### 1. 整数二分

​	二分的本质：

 1. 有单调性必然可以二分，没单调性也可以二分

 2. 整数二分的本质是，在一个区间内部，二分边界，每次都要选择答案所在的区间进行二分，最终二分到长度为1的点就是答案的点。二分一定是有解的

    算法步骤

    1. 找中间值

	3. 代码步骤

    1. 先写check 函数(包含答案的区间)
    2. 思考如何根据check函数更新区间， check 是真时，如果是 l=mid 这mid = (l+r+1)/2

##### 2. 浮点数二分

#### 高精度

​	java有高精度的实现。

1. 存储，使用数组存储。



#### 前缀和

1. 如何求s[i]
2. s[i] 有什么作用
   1. 快速求某一段的和

#### 双指针

核心思想：用某种性质将o(n2)的算法优化到O(n)

1. 两个指针 指向两个序列
2. 两个指针指向同一个序列